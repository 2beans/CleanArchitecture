# Ch6 함수형 프로그래밍
* 함수형 프로그래밍 개념은 프로그래밍 개념보다 먼저 등장.
* 패러다임의 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했다.

### 정수를 제곱하기
```Java
public class Squint {
    public static void main(String args[]) {
        for (int i=0; i< 25; i ++){
            System.out.println(i*i);
        }
    }
}
```
```Clojure
(println (take 25( map (fn [x] (* x x)) (range))))
```
```Clojure
(println ;___ 출력한다.)
    (take 25 ;___ 처음부터 25까지)
        (map (fn [x] (* x z)) ;___ 제곱을
            (range)))) ; 정수의
```
* println, take, map, range는 모두 함수다.
  * 리스프에서는 함수를 괄호안에 넣는 방식으로 호출한다.
  * range -  0부터 시작해서 끝이 없는 정수 리스트를 반환
  * map - 값을 변환(정수를 제곱)
  * take - 리스트의 앞에서부터 n개를 가져옴
  * println - 출력
* 끝이 없는 리스트지만 실제로 접근하기 전에는 평가가 이루어지지 않는다.
* 자바 프로그램은 가변변수(mutable variable)를 사용한다.
  * 가변변수는 프로그램 실행 중에 상태가 변 할 수 있다.
* 클로저에서는 x 와 같은 변수가 한번 초기화 되면 절대로 변하지 않는다.
  * 함수형 언어에서 변수는 변경되지 않는다.

```Kotlin
fun squint() {
    generateSequence(0) { it + 1 }   // 자연수
      .take(25)                      // 25까지
      .map { it * it }               // 제곱을 
      .forEach { println(it) }       // 출력
    }
```

### 불변성과 아키텍처
* 아키텍처를 고려할때 왜 변수의 **가변성**을 염두해야 하는가?
  * 경합조건(race)
  * 교착상태(deadlock)
  * 동시 업데이트(concurrent update) 
  * 3가지 문제가 모두 가변 변수로 인해 발생하기 때문이다.
* 만약 어떠한 변수도 갱신되지 않는다면 경합조건이나 동시 업데이트 문제가 일어나지 않는다.
* 락이 가변적이지 않다면 교착 상태도 일어나지 않는다.
* 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변변수가 없다면 절대로 생기지 않는다.
* 아키텍트라면 동시성문제애 지대한 관심을 가져야 한다.
* 불변성이 실제로 가능한가?
  * 저장 공간이 무한하고, 프로세서의 속도가 무한히 빠르다고 하면 가능하다.
  * 불변성은 가능하긴 하지만 일종의 타협이 필요하다.

### 가변성의 분리
* 불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 **가변 컴포넌트와 불변 컴포넌트로 분리**하는 일이다.
* 불변 컴포넌트에서는 가변을 사용하지 않음.
* 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
* 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.
* 트랜잭션 메모리는 데이터 베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다. 즉 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들 변수를 보호한다.
* 이러한 접근법의 간단한 예로 클로저의 `atom` 기능을 들을 수 있다.
```Clojure
(def counter (atom 0))  ; counter 를 0으로 초기화
(swap! counter inc)     ; counter 를 안전하게 증가
```
* `atom` 값을 변경하려면 반드시  `swap!` 함수를 사용해야 한다는 매우 엄격한 제약이 걸려 있다.
* 애플리케이션을 제대로 구조화 하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다는 것이다.
* 가변변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다.
* 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱
* 저장 공간과 처리 능력의 한계는 우리의 시야에서 급격히 사라지고 있다.
* 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.
* 상태가 필요해지면 단순히 상태이 시작점부터 모든 트랜잭션을 처리한다.
  * 고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자
    * 잔고를 변경하는 대신 트랜잭션 자체를 저장한다.
    * 누군가 잔고 조회를 요청 할 때마다 계좌 개설 시점 부터 발생한 모든 트랜잭션을 단순히 더한다.
    * 변수가 하나도 필요 없다.
    * 당연하게도 터무니 없다. 시간이 지날수록 트랜잭션 수는 끝없이 증가하고, 잔고 계산에 필요한 컴퓨팅 자원은 걷잡을 수 없이 커진다.
    * 이 전략이 영원히 실현 가능하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.
    * 영원히 동작하도록 만들 필요는 없다. 아마도 애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분할 것이다.
    * 매일 자정에 상태를 계산한 후 저장하고 그 후 상태 정보가 필요해지면 자정 이후의 트랜잭션마을 처리하는 방법도 있다.
* 아마 저장공간이 많이 필요할 것이다.
  * 요즘시대에서는 저장공간은 크게 문제 되지 않는다.
  * 더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다.
  * 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다.
  * 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.
* 저장공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들수 있고, 따라서 완전한 함수형으로 만들 수 있다.
* 터무니 없이 들린다면 소스코드 버전 관리 시스템이 정확히 이방식으로 동작한다는 사실을 떠올려 보면 도움이 될것이다.
  
### 정리
* 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
* 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
* 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
* 이들 세 패러다임 모두 우리에게서 무언가를 앗아갔다. 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지 않는다.
* 소프트웨어의 핵심은 여전히 그대로다.
  * 순차, 분기, 반복, 참조로 구성되며 그 이상 그 이하도 아니다.
