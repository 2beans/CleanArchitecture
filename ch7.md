# Ch7 SRP: 단일 책임 원칙
* 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.


## 징후 1: 우발적 중복
Employee라는 클래스가 있다. 이 클래스는 calculatePay(), reportHours(), save()를 가지고 있다.  
이 클래스는 SRP<sub>Single Responsibility Principle</sub>을 위반하는데, 세 가지 메서드가 서로 매우 다른 세 명의 이해관계자가 있기 때문이다.  
- calculatePay() 메서드는 회계팀에서 기능을 정의하며, *CFO* 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, *COO* 보고를 위해 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고, *CTO* 보고를 위해 사용한다.

이처럼 세 메서드를 Employee라는 단일 클래스에 배치하여 세명의 이해관계자가 서로 결합되어 버렸다.  
이로인해 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.


## 징후 2:  병합
소스 파일이 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다.  
DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 약간 수정하기로 결정하고 이와 동시에 인사 담당자가 속한 COO팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 결정했다고 해보자.  
두 명의 서로 다른 개발자가 Employee 클래스를 체크아웃받은 후 각자 변경사항을 적용하기 시작한다.  
안타깝게도 이들 변경사항은 서로 출동하며. *결과적으로 병합이 발생한다.*

## 해결책
이 문제의 해결책은 다양한데, 그 모두가 메서드를 각기 다른 클래스로 이동 시키는 방식이다.  
아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.  
아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 하며 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만 포함한다.  
이 방법은 *우연한 중복* 을 피할 수 있다. 하지만 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다.  
이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 퍼사드<sub>Facade</sub>패턴이 있다.  

## 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
추후 이보다 상위의 두 수준에서 다른 형태로 다시 등장 할 예정이다.
- 컴포넌트 수준에서는 공통 폐쇄 원칙<sub>Common Closure Principle</sub>
- 아키텍처 수준에서는 아키텍처 경계<sub>Architectural Boundary</sub>
