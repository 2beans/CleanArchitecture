# Chapter4 - 전상필

## 구조적 프로그래밍

## 증명
아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패하곤 했다.  
**데이크스트라는 증명<sub>proof</sub>이라는 수학적인 원리를 적용하여 해결하고자 했다.**  
그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다.  
프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시켜며, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이였다.  
당연하게도 데이크스트라는 단순한 알고리즘에 대해 기본적인 증명을 작성할 수 있는 기법을 보여줘야 한다는 사실을 깨달았다. 그러나 이 연구는 상당히 힘들어 보였다.  
데이크스트라는 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.  
goto문의 '좋은' 사용 방식은 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.  
뵙<sub>Böhm</sub>과 야코피니<sub>Jacopini</sub>는 프로그램을 순차<sub>sequence</sub> 분기<sub>selection</sub> 반복<sub>iteration</sub>이라는 **세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.**  
모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다. **구조적 프로그래밍은 이렇게 탄생했다.**

데이크스트라는 단순한 열거법을 이용해 순차 구문<sub>sequential statement</sub>이 올바름을 입증할 수 있다는 사실을 보여주었다.  

**분기<sub>selection</sub>**
분기를 통한 각 경로를 열거했다. 결과적으로 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.

**반복<sub>iteration</sub>**
반복의 경우 조금 다르다. 반복이 올바름을 증명하기 위해 데이크스트라는 귀납법<sub>induction</sub>을 사용했다.  
1의 경우가 올바름을 증명한 후 N의 경우가 올바르다고 가정할 때 N + 1의 경우도 올바름을 증명하며, 이 경우에도 열거법을 사용했다.  
또한 반복의 시작 조건과 종료 조건도 열거법을 통해 증명하였다.  
이 증명은 고되고 복잡했지만, 증명은 증명이었다.  
위 증명을 해냄으로써 프로그램에서도 정리에 대한 유클리드 계층구조를 만들 수 있을 거라는 생각이 실제로 [이루어질 듯 보였다...](#엄밀한-증명은-없었다)

## 해로운 성명서
**goto 문장은 계속 뒤편으로 밀려났고, 마침내 거의 사라졌다.** <span style="color:#cecfcf">~~찬반 전쟁은 10년 이상 지속되었다.~~</span>  

현재의 우리 모두는 구조적 프로그래머이며, 여기에는 선택의 여지가 없다.  
[ch3](https://github.com/2beans/CleanArchitecture/blob/master/ch3.md#생각할-거리)에서 이야기 했듯이 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.


## 기능적 분해
**구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.**  

거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고. 이러한 분해 과정을 끝없이 반복할 수 있다. 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.  
이를 토대로 구조적 분석<sub>structured analysis</sub>이나 구조적 설계<sub>structured design</sub>와 같은 기법이 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었다.

## 엄밀한 증명은 없었다
**하지만 끝내 증명은 이루어지지 않았다.**

프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.  
오늘 날 이처럼 엄밀한 증명이 고품질의 소프트웨어를 생산하기 위한 적절한 방법이라고 믿는 프로그래머는 이제 거의 없다.
다행히도 무언가가 올바른지를 입증할 때 사용하는 전략은 유클리드 방식같이 수학적인 증명만 있는 것이 아니다.  
상당히 성공한 또 다른 전략으로는 과학적 방법<sub>scientific method</sub>이 있다.

## 과학이 구출하다
**과학은 근본적으로 수확과는 다른데, 과학 이론과 법칙은 그 올바름이 절대 증명할 수 없기 때문이다.**  

만유인력의 법칙인 <span>F<sub>g</sub> = Gm<sub>1</sub>m<sub>2</sub>/r<sup>2</sup></span> 이 옳다고 증명할 수 없다.  
이들 법칙을 시연할 수 있고, 소수점 이하 많은 자리의 정확도로 측정할 수는 있지만, 수학적으로 증명할 수 없다.  
하지만 언젠가는 다른 실험을 통해 운동법칙과 만유인력의 법칙이 잘못되었음이 밝혀질 가능성은 항상 열려 있다.  
이 점이 바로 과학적 이론과 법칙이 지닌 본성이다. **과학적 방법은 반증은 가능하지만 증명은 불가능하다.**  
과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.  

## 테스트
**테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다. 그렇기에 테스트를 통해 프로그램이 맞다고 증명할 수는 없다.**  
**소프트웨어는 과학과 같다. 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.**  

테스트에 충분한 노력을 들엿다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.  
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.  
그러고 나서 테스트를 통해 증명 가능한 세부 기능들을 거짓임을 증명하려 테스트하고 이 테스트가 실패할 경우 해당 기능들은 목표에 부합할 만큼 충분히 참이라고 여기게 된다.

## 결론
**아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여기는 이유**  
**소프트웨어는 과학과 같고, 반증 가능성에 의해 주도된다.**

소프트웨어 아키텍트는 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용하여 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 한다.
